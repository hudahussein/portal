!function (r) { r.color = {}, r.color.make = function (t, e, i, o) { var n = {}; return n.r = t || 0, n.g = e || 0, n.b = i || 0, n.a = null != o ? o : 1, n.add = function (t, e) { for (var i = 0; i < t.length; ++i) n[t.charAt(i)] += e; return n.normalize() }, n.scale = function (t, e) { for (var i = 0; i < t.length; ++i) n[t.charAt(i)] *= e; return n.normalize() }, n.toString = function () { return 1 <= n.a ? "rgb(" + [n.r, n.g, n.b].join(",") + ")" : "rgba(" + [n.r, n.g, n.b, n.a].join(",") + ")" }, n.normalize = function () { function t(t, e, i) { return e < t ? t : i < e ? i : e } return n.r = t(0, parseInt(n.r), 255), n.g = t(0, parseInt(n.g), 255), n.b = t(0, parseInt(n.b), 255), n.a = t(0, n.a, 1), n }, n.clone = function () { return r.color.make(n.r, n.b, n.g, n.a) }, n.normalize() }, r.color.extract = function (t, e) { var i; do { if ("" != (i = t.css(e).toLowerCase()) && "transparent" != i) break; t = t.parent() } while (t.length && !r.nodeName(t.get(0), "body")); return "rgba(0, 0, 0, 0)" == i && (i = "transparent"), r.color.parse(i) }, r.color.parse = function (t) { var e, i = r.color.make; if (e = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(t)) return i(parseInt(e[1], 10), parseInt(e[2], 10), parseInt(e[3], 10)); if (e = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(t)) return i(parseInt(e[1], 10), parseInt(e[2], 10), parseInt(e[3], 10), parseFloat(e[4])); if (e = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(t)) return i(2.55 * parseFloat(e[1]), 2.55 * parseFloat(e[2]), 2.55 * parseFloat(e[3])); if (e = /rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(t)) return i(2.55 * parseFloat(e[1]), 2.55 * parseFloat(e[2]), 2.55 * parseFloat(e[3]), parseFloat(e[4])); if (e = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(t)) return i(parseInt(e[1], 16), parseInt(e[2], 16), parseInt(e[3], 16)); if (e = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(t)) return i(parseInt(e[1] + e[1], 16), parseInt(e[2] + e[2], 16), parseInt(e[3] + e[3], 16)); var o = r.trim(t).toLowerCase(); return "transparent" == o ? i(255, 255, 255, 0) : i((e = n[o] || [0, 0, 0])[0], e[1], e[2]) }; var n = { aqua: [0, 255, 255], azure: [240, 255, 255], beige: [245, 245, 220], black: [0, 0, 0], blue: [0, 0, 255], brown: [165, 42, 42], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgrey: [169, 169, 169], darkgreen: [0, 100, 0], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkviolet: [148, 0, 211], fuchsia: [255, 0, 255], gold: [255, 215, 0], green: [0, 128, 0], indigo: [75, 0, 130], khaki: [240, 230, 140], lightblue: [173, 216, 230], lightcyan: [224, 255, 255], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightyellow: [255, 255, 224], lime: [0, 255, 0], magenta: [255, 0, 255], maroon: [128, 0, 0], navy: [0, 0, 128], olive: [128, 128, 0], orange: [255, 165, 0], pink: [255, 192, 203], purple: [128, 0, 128], violet: [128, 0, 128], red: [255, 0, 0], silver: [192, 192, 192], white: [255, 255, 255], yellow: [255, 255, 0] } }(jQuery), function (G) { var m = Object.prototype.hasOwnProperty; function B(t, e) { var i = e.children("." + t)[0]; if (null == i && ((i = document.createElement("canvas")).className = t, G(i).css({ direction: "ltr", position: "absolute", left: 0, top: 0 }).appendTo(e), !i.getContext)) { if (!window.G_vmlCanvasManager) throw new Error("Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode."); i = window.G_vmlCanvasManager.initElement(i) } this.element = i; var o = this.context = i.getContext("2d"), n = window.devicePixelRatio || 1, r = o.webkitBackingStorePixelRatio || o.mozBackingStorePixelRatio || o.msBackingStorePixelRatio || o.oBackingStorePixelRatio || o.backingStorePixelRatio || 1; this.pixelRatio = n / r, this.resize(e.width(), e.height()), this.textContainer = null, this.text = {}, this._textCache = {} } function o(g, t, e, o) { var z = [], S = { colors: ["#edc240", "#afd8f8", "#cb4b4b", "#4da74d", "#9440ed"], legend: { show: !0, noColumns: 1, labelFormatter: null, labelBoxBorderColor: "#ccc", container: null, position: "ne", margin: 5, backgroundColor: null, backgroundOpacity: .85, sorted: null }, xaxis: { show: null, position: "bottom", mode: null, font: null, color: null, tickColor: null, transform: null, inverseTransform: null, min: null, max: null, autoscaleMargin: null, ticks: null, tickFormatter: null, labelWidth: null, labelHeight: null, reserveSpace: null, tickLength: null, alignTicksWithAxis: null, tickDecimals: null, tickSize: null, minTickSize: null }, yaxis: { autoscaleMargin: .02, position: "left" }, xaxes: [], yaxes: [], series: { points: { show: !1, radius: 3, lineWidth: 2, fill: !0, fillColor: "#ffffff", symbol: "circle" }, lines: { lineWidth: 2, fill: !1, fillColor: null, steps: !1 }, bars: { show: !1, lineWidth: 2, barWidth: 1, fill: !0, fillColor: null, align: "left", horizontal: !1, zero: !0 }, shadowSize: 3, highlightColor: null }, grid: { show: !0, aboveData: !1, color: "#545454", backgroundColor: null, borderColor: null, tickColor: null, margin: 0, labelMargin: 5, axisMargin: 8, borderWidth: 2, minBorderMargin: null, markings: null, markingsColor: "#f4f4f4", markingsLineWidth: 2, clickable: !1, hoverable: !1, autoHighlight: !0, mouseActiveRadius: 10 }, interaction: { redrawOverlayInterval: 1e3 / 60 }, hooks: {} }, m = null, i = null, u = null, y = null, c = null, d = [], p = [], w = { left: 0, right: 0, top: 0, bottom: 0 }, M = 0, T = 0, C = { processOptions: [], processRawData: [], processDatapoints: [], processOffset: [], drawBackground: [], drawSeries: [], draw: [], bindEvents: [], drawOverlay: [], shutdown: [] }, W = this; function A(t, e) { e = [W].concat(e); for (var i = 0; i < t.length; ++i) t[i].apply(this, e) } function n(t) { z = function (t) { for (var e = [], i = 0; i < t.length; ++i) { var o = G.extend(!0, {}, S.series); null != t[i].data ? (o.data = t[i].data, delete t[i].data, G.extend(!0, o, t[i]), t[i].data = o.data) : o.data = t[i], e.push(o) } return e }(t), function () { var t, e = z.length, i = -1; for (t = 0; t < z.length; ++t) { var o = z[t].color; null != o && (e--, "number" == typeof o && i < o && (i = o)) } e <= i && (e = i + 1); var n, r = [], a = S.colors, l = a.length, s = 0; for (t = 0; t < e; t++) n = G.color.parse(a[t % l] || "#666"), t % l == 0 && t && (s = 0 <= s ? s < .5 ? -s - .2 : 0 : -s), r[t] = n.scale("rgb", 1 + s); var c, u = 0; for (t = 0; t < z.length; ++t) { if (null == (c = z[t]).color ? (c.color = r[u].toString(), ++u) : "number" == typeof c.color && (c.color = r[c.color].toString()), null == c.lines.show) { var h, f = !0; for (h in c) if (c[h] && c[h].show) { f = !1; break } f && (c.lines.show = !0) } null == c.lines.zero && (c.lines.zero = !!c.lines.fill), c.xaxis = b(d, x(c, "x")), c.yaxis = b(p, x(c, "y")) } }(), function () { var t, e, i, o, n, r, a, l, s, c, u, h, f, m = Number.POSITIVE_INFINITY, d = Number.NEGATIVE_INFINITY, p = Number.MAX_VALUE; function g(t, e, i) { e < t.datamin && e != -p && (t.datamin = e), i > t.datamax && i != p && (t.datamax = i) } for (G.each(F(), function (t, e) { e.datamin = m, e.datamax = d, e.used = !1 }), t = 0; t < z.length; ++t) (n = z[t]).datapoints = { points: [] }, A(C.processRawData, [n, n.data, n.datapoints]); for (t = 0; t < z.length; ++t) { var x; if (n = z[t], u = n.data, (h = n.datapoints.format) || ((h = []).push({ x: !0, number: !0, required: !0 }), h.push({ y: !0, number: !0, required: !0 }), (n.bars.show || n.lines.show && n.lines.fill) && (x = !!(n.bars.show && n.bars.zero || n.lines.show && n.lines.zero), h.push({ y: !0, number: !0, required: !1, defaultValue: 0, autoscale: x }), n.bars.horizontal && (delete h[h.length - 1].y, h[h.length - 1].x = !0)), n.datapoints.format = h), null == n.datapoints.pointsize) { n.datapoints.pointsize = h.length, a = n.datapoints.pointsize, r = n.datapoints.points; var b = n.lines.show && n.lines.steps; for (n.xaxis.used = n.yaxis.used = !0, e = i = 0; e < u.length; ++e, i += a) { var v = null == (c = u[e]); if (!v) for (o = 0; o < a; ++o) l = c[o], (s = h[o]) && (s.number && null != l && (l = +l, isNaN(l) ? l = null : l == 1 / 0 ? l = p : l == -1 / 0 && (l = -p)), null == l && (s.required && (v = !0), null != s.defaultValue && (l = s.defaultValue))), r[i + o] = l; if (v) for (o = 0; o < a; ++o) null != (l = r[i + o]) && !1 !== (s = h[o]).autoscale && (s.x && g(n.xaxis, l, l), s.y && g(n.yaxis, l, l)), r[i + o] = null; else if (b && 0 < i && null != r[i - a] && r[i - a] != r[i] && r[i - a + 1] != r[i + 1]) { for (o = 0; o < a; ++o) r[i + a + o] = r[i + o]; r[i + 1] = r[i - a + 1], i += a } } } } for (t = 0; t < z.length; ++t) n = z[t], A(C.processDatapoints, [n, n.datapoints]); for (t = 0; t < z.length; ++t) { n = z[t], r = n.datapoints.points, a = n.datapoints.pointsize, h = n.datapoints.format; var k = m, y = m, w = d, M = d; for (e = 0; e < r.length; e += a) if (null != r[e]) for (o = 0; o < a; ++o) l = r[e + o], (s = h[o]) && !1 !== s.autoscale && l != p && l != -p && (s.x && (l < k && (k = l), w < l && (w = l)), s.y && (l < y && (y = l), M < l && (M = l))); if (n.bars.show) { switch (n.bars.align) { case "left": f = 0; break; case "right": f = -n.bars.barWidth; break; default: f = -n.bars.barWidth / 2 } n.bars.horizontal ? (y += f, M += f + n.bars.barWidth) : (k += f, w += f + n.bars.barWidth) } g(n.xaxis, k, w), g(n.yaxis, y, M) } G.each(F(), function (t, e) { e.datamin == m && (e.datamin = null), e.datamax == d && (e.datamax = null) }) }() } function x(t, e) { var i = t[e + "axis"]; return "object" == typeof i && (i = i.n), "number" != typeof i && (i = 1), i } function F() { return G.grep(d.concat(p), function (t) { return t }) } function h(t) { for (var e, i = {}, o = 0; o < d.length; ++o) (e = d[o]) && e.used && (i["x" + e.n] = e.c2p(t.left)); for (o = 0; o < p.length; ++o) (e = p[o]) && e.used && (i["y" + e.n] = e.c2p(t.top)); return void 0 !== i.x1 && (i.x = i.x1), void 0 !== i.y1 && (i.y = i.y1), i } function b(t, e) { return t[e - 1] || (t[e - 1] = { n: e, direction: t == d ? "x" : "y", options: G.extend(!0, {}, t == d ? S.xaxis : S.yaxis) }), t[e - 1] } function r() { D && clearTimeout(D), u.unbind("mousemove", q), u.unbind("mouseleave", N), u.unbind("click", P), A(C.shutdown, [u]) } function a() { var t, e = F(), i = S.grid.show; for (var o in w) { var n = S.grid.margin || 0; w[o] = "number" == typeof n ? n : n[o] || 0 } for (var o in A(C.processOffset, [w]), w) "object" == typeof S.grid.borderWidth ? w[o] += i ? S.grid.borderWidth[o] : 0 : w[o] += i ? S.grid.borderWidth : 0; if (G.each(e, function (t, e) { var i = e.options; e.show = null == i.show ? e.used : i.show, e.reserveSpace = null == i.reserveSpace ? e.show : i.reserveSpace, function (t) { var e = t.options, i = +(null != e.min ? e.min : t.datamin), o = +(null != e.max ? e.max : t.datamax), n = o - i; { var r, a; 0 == n ? (r = 0 == o ? 1 : .01, null == e.min && (i -= r), null != e.max && null == e.min || (o += r)) : null != (a = e.autoscaleMargin) && (null == e.min && (i -= n * a) < 0 && null != t.datamin && 0 <= t.datamin && (i = 0), null == e.max && 0 < (o += n * a) && null != t.datamax && t.datamax <= 0 && (o = 0)) } t.min = i, t.max = o }(e) }), i) { var r = G.grep(e, function (t) { return t.show || t.reserveSpace }); for (G.each(r, function (t, e) { var i, o; !function (t) { var e, i = t.options; e = "number" == typeof i.ticks && 0 < i.ticks ? i.ticks : .3 * Math.sqrt("x" == t.direction ? m.width : m.height); var o = (t.max - t.min) / e, n = -Math.floor(Math.log(o) / Math.LN10), r = i.tickDecimals; null != r && r < n && (n = r); var a, l = Math.pow(10, -n), s = o / l; s < 1.5 ? a = 1 : s < 3 ? (a = 2, 2.25 < s && (null == r || n + 1 <= r) && (a = 2.5, ++n)) : a = s < 7.5 ? 5 : 10; a *= l, null != i.minTickSize && a < i.minTickSize && (a = i.minTickSize); if (t.delta = o, t.tickDecimals = Math.max(0, null != r ? r : n), t.tickSize = i.tickSize || a, "time" == i.mode && !t.tickGenerator) throw new Error("Time mode requires the flot.time plugin."); t.tickGenerator || (t.tickGenerator = function (t) { for (var e, i, o, n = [], r = (i = t.min, (o = t.tickSize) * Math.floor(i / o)), a = 0, l = Number.NaN; e = l, l = r + a * t.tickSize, n.push(l), ++a, l < t.max && l != e;); return n }, t.tickFormatter = function (t, e) { var i = e.tickDecimals ? Math.pow(10, e.tickDecimals) : 1, o = "" + Math.round(t * i) / i; if (null != e.tickDecimals) { var n = o.indexOf("."), r = -1 == n ? 0 : o.length - n - 1; if (r < e.tickDecimals) return (r ? o : o + ".") + ("" + i).substr(1, e.tickDecimals - r) } return o }); G.isFunction(i.tickFormatter) && (t.tickFormatter = function (t, e) { return "" + i.tickFormatter(t, e) }); { var c, u, h, f; null == i.alignTicksWithAxis || (c = ("x" == t.direction ? d : p)[i.alignTicksWithAxis - 1]) && c.used && c != t && (0 < (u = t.tickGenerator(t)).length && (null == i.min && (t.min = Math.min(t.min, u[0])), null == i.max && 1 < u.length && (t.max = Math.max(t.max, u[u.length - 1]))), t.tickGenerator = function (t) { for (var e, i = [], o = 0; o < c.ticks.length; ++o) e = (c.ticks[o].v - c.min) / (c.max - c.min), e = t.min + e * (t.max - t.min), i.push(e); return i }, t.mode || null != i.tickDecimals || (h = Math.max(0, 1 - Math.floor(Math.log(t.delta) / Math.LN10)), 1 < (f = t.tickGenerator(t)).length && /\..*0$/.test((f[1] - f[0]).toFixed(h)) || (t.tickDecimals = h))) } }(e), function (t) { var e, i, o = t.options.ticks, n = []; null == o || "number" == typeof o && 0 < o ? n = t.tickGenerator(t) : o && (n = G.isFunction(o) ? o(t) : o); for (t.ticks = [], e = 0; e < n.length; ++e) { var r = null, a = n[e]; "object" == typeof a ? (i = +a[0], 1 < a.length && (r = a[1])) : i = +a, null == r && (r = t.tickFormatter(i, t)), isNaN(i) || t.ticks.push({ v: i, label: r }) } }(e), o = (i = e).ticks, i.options.autoscaleMargin && 0 < o.length && (null == i.options.min && (i.min = Math.min(i.min, o[0].v)), null == i.options.max && 1 < o.length && (i.max = Math.max(i.max, o[o.length - 1].v))), function (t) { for (var e = t.options, i = t.ticks || [], o = e.labelWidth || 0, n = e.labelHeight || 0, r = o || ("x" == t.direction ? Math.floor(m.width / (i.length || 1)) : null), a = t.direction + "Axis " + t.direction + t.n + "Axis", l = "flot-" + t.direction + "-axis flot-" + t.direction + t.n + "-axis " + a, s = e.font || "flot-tick-label tickLabel", c = 0; c < i.length; ++c) { var u, h = i[c]; h.label && (u = m.getTextInfo(l, h.label, s, null, r), o = Math.max(o, u.width), n = Math.max(n, u.height)) } t.labelWidth = e.labelWidth || o, t.labelHeight = e.labelHeight || n }(e) }), t = r.length - 1; 0 <= t; --t) !function (i) { var t = i.labelWidth, e = i.labelHeight, o = i.options.position, n = "x" === i.direction, r = i.options.tickLength, a = S.grid.axisMargin, l = S.grid.labelMargin, s = !0, c = !0, u = !0, h = !1; G.each(n ? d : p, function (t, e) { e && (e.show || e.reserveSpace) && (e === i ? h = !0 : e.options.position === o && (h ? c = !1 : s = !1), h || (u = !1)) }), c && (a = 0), null == r && (r = u ? "full" : 5), isNaN(+r) || (l += +r), n ? (e += l, "bottom" == o ? (w.bottom += e + a, i.box = { top: m.height - w.bottom, height: e }) : (i.box = { top: w.top + a, height: e }, w.top += e + a)) : (t += l, "left" == o ? (i.box = { left: w.left + a, width: t }, w.left += t + a) : (w.right += t + a, i.box = { left: m.width - w.right, width: t })), i.position = o, i.tickLength = r, i.box.padding = l, i.innermost = s }(r[t]); !function () { var t, e = S.grid.minBorderMargin; if (null == e) for (t = e = 0; t < z.length; ++t) e = Math.max(e, 2 * (z[t].points.radius + z[t].points.lineWidth / 2)); var i = { left: e, right: e, top: e, bottom: e }; G.each(F(), function (t, e) { e.reserveSpace && e.ticks && e.ticks.length && ("x" === e.direction ? (i.left = Math.max(i.left, e.labelWidth / 2), i.right = Math.max(i.right, e.labelWidth / 2)) : (i.bottom = Math.max(i.bottom, e.labelHeight / 2), i.top = Math.max(i.top, e.labelHeight / 2))) }), w.left = Math.ceil(Math.max(i.left, w.left)), w.right = Math.ceil(Math.max(i.right, w.right)), w.top = Math.ceil(Math.max(i.top, w.top)), w.bottom = Math.ceil(Math.max(i.bottom, w.bottom)) }(), G.each(r, function (t, e) { var i; "x" == (i = e).direction ? (i.box.left = w.left - i.labelWidth / 2, i.box.width = m.width - w.left - w.right + i.labelWidth) : (i.box.top = w.top - i.labelHeight / 2, i.box.height = m.height - w.bottom - w.top + i.labelHeight) }) } M = m.width - w.left - w.right, T = m.height - w.bottom - w.top, G.each(e, function (t, e) { function i(t) { return t } var o, n, r, a, l; r = (o = e).options.transform || i, a = o.options.inverseTransform, l = "x" == o.direction ? (n = o.scale = M / Math.abs(r(o.max) - r(o.min)), Math.min(r(o.max), r(o.min))) : (n = -(n = o.scale = T / Math.abs(r(o.max) - r(o.min))), Math.max(r(o.max), r(o.min))), o.p2c = r == i ? function (t) { return (t - l) * n } : function (t) { return (r(t) - l) * n }, o.c2p = a ? function (t) { return a(l + t / n) } : function (t) { return l + t / n } }), i && G.each(F(), function (t, e) { var i, o, n, r, a, l = e.box, s = e.direction + "Axis " + e.direction + e.n + "Axis", c = "flot-" + e.direction + "-axis flot-" + e.direction + e.n + "-axis " + s, u = e.options.font || "flot-tick-label tickLabel"; if (m.removeText(c), e.show && 0 != e.ticks.length) for (var h = 0; h < e.ticks.length; ++h) !(i = e.ticks[h]).label || i.v < e.min || i.v > e.max || ("x" == e.direction ? (r = "center", o = w.left + e.p2c(i.v), "bottom" == e.position ? n = l.top + l.padding : (n = l.top + l.height - l.padding, a = "bottom")) : (a = "middle", n = w.top + e.p2c(i.v), "left" == e.position ? (o = l.left + l.width - l.padding, r = "right") : o = l.left + l.padding), m.addText(c, o, n, i.label, u, null, null, r, a)) }), function () { null != S.legend.container ? G(S.legend.container).html("") : g.find(".legend").remove(); if (!S.legend.show) return; for (var t, e, i = [], o = [], n = !1, r = S.legend.labelFormatter, a = 0; a < z.length; ++a) (t = z[a]).label && (e = r ? r(t.label, t) : t.label) && o.push({ label: e, color: t.color }); { var l; S.legend.sorted && (G.isFunction(S.legend.sorted) ? o.sort(S.legend.sorted) : "reverse" == S.legend.sorted ? o.reverse() : (l = "descending" != S.legend.sorted, o.sort(function (t, e) { return t.label == e.label ? 0 : t.label < e.label != l ? 1 : -1 }))) } for (a = 0; a < o.length; ++a) { var s = o[a]; a % S.legend.noColumns == 0 && (n && i.push("</tr>"), i.push("<tr>"), n = !0), i.push('<td class="legendColorBox"><div style="border:1px solid ' + S.legend.labelBoxBorderColor + ';padding:1px"><div style="width:4px;height:0;border:5px solid ' + s.color + ';overflow:hidden"></div></div></td><td class="legendLabel">' + s.label + "</td>") } n && i.push("</tr>"); if (0 == i.length) return; var c = '<table style="font-size:smaller;color:' + S.grid.color + '">' + i.join("") + "</table>"; { var u, h, f, m, d, p; null != S.legend.container ? G(S.legend.container).html(c) : (u = "", h = S.legend.position, null == (f = S.legend.margin)[0] && (f = [f, f]), "n" == h.charAt(0) ? u += "top:" + (f[1] + w.top) + "px;" : "s" == h.charAt(0) && (u += "bottom:" + (f[1] + w.bottom) + "px;"), "e" == h.charAt(1) ? u += "right:" + (f[0] + w.right) + "px;" : "w" == h.charAt(1) && (u += "left:" + (f[0] + w.left) + "px;"), m = G('<div class="legend">' + c.replace('style="', 'style="position:absolute;' + u + ";") + "</div>").appendTo(g), 0 != S.legend.backgroundOpacity && (null == (d = S.legend.backgroundColor) && ((d = (d = S.grid.backgroundColor) && "string" == typeof d ? G.color.parse(d) : G.color.extract(m, "background-color")).a = 1, d = d.toString()), p = m.children(), G('<div style="position:absolute;width:' + p.width() + "px;height:" + p.height() + "px;" + u + "background-color:" + d + ';"> </div>').prependTo(m).css("opacity", S.legend.backgroundOpacity))) } }() } function l() { m.clear(), A(C.drawBackground, [y]); var t = S.grid; t.show && t.backgroundColor && (y.save(), y.translate(w.left, w.top), y.fillStyle = E(S.grid.backgroundColor, T, 0, "rgba(255, 255, 255, 0)"), y.fillRect(0, 0, M, T), y.restore()), t.show && !t.aboveData && s(); for (var e = 0; e < z.length; ++e) A(C.drawSeries, [y, z[e]]), function (t) { t.lines.show && function (t) { function e(t, e, i, o, n) { var r = t.points, a = t.pointsize, l = null, s = null; y.beginPath(); for (var c = a; c < r.length; c += a) { var u = r[c - a], h = r[c - a + 1], f = r[c], m = r[c + 1]; if (null != u && null != f) { if (h <= m && h < n.min) { if (m < n.min) continue; u = (n.min - h) / (m - h) * (f - u) + u, h = n.min } else if (m <= h && m < n.min) { if (h < n.min) continue; f = (n.min - h) / (m - h) * (f - u) + u, m = n.min } if (m <= h && h > n.max) { if (m > n.max) continue; u = (n.max - h) / (m - h) * (f - u) + u, h = n.max } else if (h <= m && m > n.max) { if (h > n.max) continue; f = (n.max - h) / (m - h) * (f - u) + u, m = n.max } if (u <= f && u < o.min) { if (f < o.min) continue; h = (o.min - u) / (f - u) * (m - h) + h, u = o.min } else if (f <= u && f < o.min) { if (u < o.min) continue; m = (o.min - u) / (f - u) * (m - h) + h, f = o.min } if (f <= u && u > o.max) { if (f > o.max) continue; h = (o.max - u) / (f - u) * (m - h) + h, u = o.max } else if (u <= f && f > o.max) { if (u > o.max) continue; m = (o.max - u) / (f - u) * (m - h) + h, f = o.max } u == l && h == s || y.moveTo(o.p2c(u) + e, n.p2c(h) + i), l = f, s = m, y.lineTo(o.p2c(f) + e, n.p2c(m) + i) } } y.stroke() } y.save(), y.translate(w.left, w.top), y.lineJoin = "round"; var i = t.lines.lineWidth, o = t.shadowSize; { var n; 0 < i && 0 < o && (y.lineWidth = o, y.strokeStyle = "rgba(0,0,0,0.1)", n = Math.PI / 18, e(t.datapoints, Math.sin(n) * (i / 2 + o / 2), Math.cos(n) * (i / 2 + o / 2), t.xaxis, t.yaxis), y.lineWidth = o / 2, e(t.datapoints, Math.sin(n) * (i / 2 + o / 4), Math.cos(n) * (i / 2 + o / 4), t.xaxis, t.yaxis)) } y.lineWidth = i, y.strokeStyle = t.color; var r = v(t.lines, t.color, 0, T); r && (y.fillStyle = r, function (t, e, i) { for (var o = t.points, n = t.pointsize, r = Math.min(Math.max(0, i.min), i.max), a = 0, l = !1, s = 1, c = 0, u = 0; !(0 < n && a > o.length + n) ;) { var h, f, m = o[(a += n) - n], d = o[a - n + s], p = o[a], g = o[a + s]; if (l) { if (0 < n && null != m && null == p) { u = a, n = -n, s = 2; continue } if (n < 0 && a == c + n) { y.fill(), l = !1, s = 1, a = c = u + (n = -n); continue } } if (null != m && null != p) { if (m <= p && m < e.min) { if (p < e.min) continue; d = (e.min - m) / (p - m) * (g - d) + d, m = e.min } else if (p <= m && p < e.min) { if (m < e.min) continue; g = (e.min - m) / (p - m) * (g - d) + d, p = e.min } if (p <= m && m > e.max) { if (p > e.max) continue; d = (e.max - m) / (p - m) * (g - d) + d, m = e.max } else if (m <= p && p > e.max) { if (m > e.max) continue; g = (e.max - m) / (p - m) * (g - d) + d, p = e.max } l || (y.beginPath(), y.moveTo(e.p2c(m), i.p2c(r)), l = !0), d >= i.max && g >= i.max ? (y.lineTo(e.p2c(m), i.p2c(i.max)), y.lineTo(e.p2c(p), i.p2c(i.max))) : d <= i.min && g <= i.min ? (y.lineTo(e.p2c(m), i.p2c(i.min)), y.lineTo(e.p2c(p), i.p2c(i.min))) : (h = m, f = p, d <= g && d < i.min && g >= i.min ? (m = (i.min - d) / (g - d) * (p - m) + m, d = i.min) : g <= d && g < i.min && d >= i.min && (p = (i.min - d) / (g - d) * (p - m) + m, g = i.min), g <= d && d > i.max && g <= i.max ? (m = (i.max - d) / (g - d) * (p - m) + m, d = i.max) : d <= g && g > i.max && d <= i.max && (p = (i.max - d) / (g - d) * (p - m) + m, g = i.max), m != h && y.lineTo(e.p2c(h), i.p2c(d)), y.lineTo(e.p2c(m), i.p2c(d)), y.lineTo(e.p2c(p), i.p2c(g)), p != f && (y.lineTo(e.p2c(p), i.p2c(g)), y.lineTo(e.p2c(f), i.p2c(g)))) } } }(t.datapoints, t.xaxis, t.yaxis)); 0 < i && e(t.datapoints, 0, 0, t.xaxis, t.yaxis); y.restore() }(t); t.bars.show && function (c) { var t; switch (y.save(), y.translate(w.left, w.top), y.lineWidth = c.bars.lineWidth, y.strokeStyle = c.color, c.bars.align) { case "left": t = 0; break; case "right": t = -c.bars.barWidth; break; default: t = -c.bars.barWidth / 2 } var e = c.bars.fill ? function (t, e) { return v(c.bars, c.color, t, e) } : null; (function (t, e, i, o, n, r) { for (var a = t.points, l = t.pointsize, s = 0; s < a.length; s += l) null != a[s] && f(a[s], a[s + 1], a[s + 2], e, i, o, n, r, y, c.bars.horizontal, c.bars.lineWidth) })(c.datapoints, t, t + c.bars.barWidth, e, c.xaxis, c.yaxis), y.restore() }(t); t.points.show && function (t) { function e(t, e, i, o, n, r, a, l) { for (var s = t.points, c = t.pointsize, u = 0; u < s.length; u += c) { var h = s[u], f = s[u + 1]; null == h || h < r.min || h > r.max || f < a.min || f > a.max || (y.beginPath(), h = r.p2c(h), f = a.p2c(f) + o, "circle" == l ? y.arc(h, f, e, 0, n ? Math.PI : 2 * Math.PI, !1) : l(y, h, f, e, n), y.closePath(), i && (y.fillStyle = i, y.fill()), y.stroke()) } } y.save(), y.translate(w.left, w.top); var i = t.points.lineWidth, o = t.shadowSize, n = t.points.radius, r = t.points.symbol; 0 == i && (i = 1e-4); { var a; 0 < i && 0 < o && (a = o / 2, y.lineWidth = a, y.strokeStyle = "rgba(0,0,0,0.1)", e(t.datapoints, n, null, a + a / 2, !0, t.xaxis, t.yaxis, r), y.strokeStyle = "rgba(0,0,0,0.2)", e(t.datapoints, n, null, a / 2, !0, t.xaxis, t.yaxis, r)) } y.lineWidth = i, y.strokeStyle = t.color, e(t.datapoints, n, v(t.points, t.color), 0, !1, t.xaxis, t.yaxis, r), y.restore() }(t) }(z[e]); A(C.draw, [y]), t.show && t.aboveData && s(), m.render(), R() } function I(t, e) { for (var i, o, n, r, a, l = F(), s = 0; s < l.length; ++s) if ((i = l[s]).direction == e && (t[o = e + i.n + "axis"] || 1 != i.n || (o = e + "axis"), t[o])) { r = t[o].from, a = t[o].to; break } return t[o] || (i = "x" == e ? d[0] : p[0], r = t[e + "1"], a = t[e + "2"]), null != r && null != a && a < r && (n = r, r = a, a = n), { from: r, to: a, axis: i } } function s() { var t, e, i, o; y.save(), y.translate(w.left, w.top); var n = S.grid.markings; if (n) for (G.isFunction(n) && ((e = W.getAxes()).xmin = e.xaxis.min, e.xmax = e.xaxis.max, e.ymin = e.yaxis.min, e.ymax = e.yaxis.max, n = n(e)), t = 0; t < n.length; ++t) { var r, a, l, s, c = n[t], u = I(c, "x"), h = I(c, "y"); null == u.from && (u.from = u.axis.min), null == u.to && (u.to = u.axis.max), null == h.from && (h.from = h.axis.min), null == h.to && (h.to = h.axis.max), u.to < u.axis.min || u.from > u.axis.max || h.to < h.axis.min || h.from > h.axis.max || (u.from = Math.max(u.from, u.axis.min), u.to = Math.min(u.to, u.axis.max), h.from = Math.max(h.from, h.axis.min), h.to = Math.min(h.to, h.axis.max), r = u.from === u.to, a = h.from === h.to, r && a || (u.from = Math.floor(u.axis.p2c(u.from)), u.to = Math.floor(u.axis.p2c(u.to)), h.from = Math.floor(h.axis.p2c(h.from)), h.to = Math.floor(h.axis.p2c(h.to)), r || a ? (s = (l = c.lineWidth || S.grid.markingsLineWidth) % 2 ? .5 : 0, y.beginPath(), y.strokeStyle = c.color || S.grid.markingsColor, y.lineWidth = l, r ? (y.moveTo(u.to + s, h.from), y.lineTo(u.to + s, h.to)) : (y.moveTo(u.from, h.to + s), y.lineTo(u.to, h.to + s)), y.stroke()) : (y.fillStyle = c.color || S.grid.markingsColor, y.fillRect(u.from, h.to, u.to - u.from, h.from - h.to)))) } e = F(), i = S.grid.borderWidth; for (var f = 0; f < e.length; ++f) { var m, d, p, g = e[f], x = g.box, b = g.tickLength; if (g.show && 0 != g.ticks.length) { for (y.lineWidth = 1, "x" == g.direction ? (m = 0, d = "full" == b ? "top" == g.position ? 0 : T : x.top - w.top + ("top" == g.position ? x.height : 0)) : (d = 0, m = "full" == b ? "left" == g.position ? 0 : M : x.left - w.left + ("left" == g.position ? x.width : 0)), g.innermost || (y.strokeStyle = g.options.color, y.beginPath(), k = p = 0, "x" == g.direction ? k = M + 1 : p = T + 1, 1 == y.lineWidth && ("x" == g.direction ? d = Math.floor(d) + .5 : m = Math.floor(m) + .5), y.moveTo(m, d), y.lineTo(m + k, d + p), y.stroke()), y.strokeStyle = g.options.tickColor, y.beginPath(), t = 0; t < g.ticks.length; ++t) { var v = g.ticks[t].v, k = p = 0; isNaN(v) || v < g.min || v > g.max || "full" == b && ("object" == typeof i && 0 < i[g.position] || 0 < i) && (v == g.min || v == g.max) || ("x" == g.direction ? (m = g.p2c(v), p = "full" == b ? -T : b, "top" == g.position && (p = -p)) : (d = g.p2c(v), k = "full" == b ? -M : b, "left" == g.position && (k = -k)), 1 == y.lineWidth && ("x" == g.direction ? m = Math.floor(m) + .5 : d = Math.floor(d) + .5), y.moveTo(m, d), y.lineTo(m + k, d + p)) } y.stroke() } } i && (o = S.grid.borderColor, "object" == typeof i || "object" == typeof o ? ("object" != typeof i && (i = { top: i, right: i, bottom: i, left: i }), "object" != typeof o && (o = { top: o, right: o, bottom: o, left: o }), 0 < i.top && (y.strokeStyle = o.top, y.lineWidth = i.top, y.beginPath(), y.moveTo(0 - i.left, 0 - i.top / 2), y.lineTo(M, 0 - i.top / 2), y.stroke()), 0 < i.right && (y.strokeStyle = o.right, y.lineWidth = i.right, y.beginPath(), y.moveTo(M + i.right / 2, 0 - i.top), y.lineTo(M + i.right / 2, T), y.stroke()), 0 < i.bottom && (y.strokeStyle = o.bottom, y.lineWidth = i.bottom, y.beginPath(), y.moveTo(M + i.right, T + i.bottom / 2), y.lineTo(0, T + i.bottom / 2), y.stroke()), 0 < i.left && (y.strokeStyle = o.left, y.lineWidth = i.left, y.beginPath(), y.moveTo(0 - i.left / 2, T + i.bottom), y.lineTo(0 - i.left / 2, 0), y.stroke())) : (y.lineWidth = i, y.strokeStyle = S.grid.borderColor, y.strokeRect(-i / 2, -i / 2, M + i, T + i))), y.restore() } function f(t, e, i, o, n, r, a, l, s, c, u) { var h, f, m, d, p, g, x, b, v; c ? (p = !(b = g = x = !0), d = e + o, m = e + n, (f = t) < (h = i) && (v = f, f = h, h = v, g = !(p = !0))) : (b = !(p = g = x = !0), h = t + o, f = t + n, (d = e) < (m = i) && (v = d, d = m, m = v, x = !(b = !0))), f < a.min || h > a.max || d < l.min || m > l.max || (h < a.min && (h = a.min, p = !1), f > a.max && (f = a.max, g = !1), m < l.min && (m = l.min, b = !1), d > l.max && (d = l.max, x = !1), h = a.p2c(h), m = l.p2c(m), f = a.p2c(f), d = l.p2c(d), r && (s.fillStyle = r(m, d), s.fillRect(h, d, f - h, m - d)), 0 < u && (p || g || x || b) && (s.beginPath(), s.moveTo(h, m), p ? s.lineTo(h, d) : s.moveTo(h, d), x ? s.lineTo(f, d) : s.moveTo(f, d), g ? s.lineTo(f, m) : s.moveTo(f, m), b ? s.lineTo(h, m) : s.moveTo(h, m), s.stroke())) } function v(t, e, i, o) { var n = t.fill; if (!n) return null; if (t.fillColor) return E(t.fillColor, i, o, e); var r = G.color.parse(e); return r.a = "number" == typeof n ? n : .4, r.normalize(), r.toString() } W.setData = n, W.setupGrid = a, W.draw = l, W.getPlaceholder = function () { return g }, W.getCanvas = function () { return m.element }, W.getPlotOffset = function () { return w }, W.width = function () { return M }, W.height = function () { return T }, W.offset = function () { var t = u.offset(); return t.left += w.left, t.top += w.top, t }, W.getData = function () { return z }, W.getAxes = function () { var i = {}; return G.each(d.concat(p), function (t, e) { e && (i[e.direction + (1 != e.n ? e.n : "") + "axis"] = e) }), i }, W.getXAxes = function () { return d }, W.getYAxes = function () { return p }, W.c2p = h, W.p2c = function (t) { var e, i, o, n = {}; for (e = 0; e < d.length; ++e) if ((i = d[e]) && i.used && (o = "x" + i.n, null == t[o] && 1 == i.n && (o = "x"), null != t[o])) { n.left = i.p2c(t[o]); break } for (e = 0; e < p.length; ++e) if ((i = p[e]) && i.used && (o = "y" + i.n, null == t[o] && 1 == i.n && (o = "y"), null != t[o])) { n.top = i.p2c(t[o]); break } return n }, W.getOptions = function () { return S }, W.highlight = j, W.unhighlight = L, W.triggerRedrawOverlay = R, W.pointOffset = function (t) { return { left: parseInt(d[x(t, "x") - 1].p2c(+t.x) + w.left, 10), top: parseInt(p[x(t, "y") - 1].p2c(+t.y) + w.top, 10) } }, W.shutdown = r, W.destroy = function () { r(), g.removeData("plot").empty(), z = [], d = [], p = [], k = [], W = C = c = y = u = i = m = S = null }, W.resize = function () { var t = g.width(), e = g.height(); m.resize(t, e), i.resize(t, e) }, W.hooks = C, function () { for (var t = { Canvas: B }, e = 0; e < o.length; ++e) { var i = o[e]; i.init(W, t), i.options && G.extend(!0, S, i.options) } }(), function (t) { G.extend(!0, S, t), t && t.colors && (S.colors = t.colors); null == S.xaxis.color && (S.xaxis.color = G.color.parse(S.grid.color).scale("a", .22).toString()); null == S.yaxis.color && (S.yaxis.color = G.color.parse(S.grid.color).scale("a", .22).toString()); null == S.xaxis.tickColor && (S.xaxis.tickColor = S.grid.tickColor || S.xaxis.color); null == S.yaxis.tickColor && (S.yaxis.tickColor = S.grid.tickColor || S.yaxis.color); null == S.grid.borderColor && (S.grid.borderColor = S.grid.color); null == S.grid.tickColor && (S.grid.tickColor = G.color.parse(S.grid.color).scale("a", .22).toString()); var e, i, o, n = g.css("font-size"), r = n ? +n.replace("px", "") : 13, a = { style: g.css("font-style"), size: Math.round(.8 * r), variant: g.css("font-variant"), weight: g.css("font-weight"), family: g.css("font-family") }; for (o = S.xaxes.length || 1, e = 0; e < o; ++e) (i = S.xaxes[e]) && !i.tickColor && (i.tickColor = i.color), i = G.extend(!0, {}, S.xaxis, i), (S.xaxes[e] = i).font && (i.font = G.extend({}, a, i.font), i.font.color || (i.font.color = i.color), i.font.lineHeight || (i.font.lineHeight = Math.round(1.15 * i.font.size))); for (o = S.yaxes.length || 1, e = 0; e < o; ++e) (i = S.yaxes[e]) && !i.tickColor && (i.tickColor = i.color), i = G.extend(!0, {}, S.yaxis, i), (S.yaxes[e] = i).font && (i.font = G.extend({}, a, i.font), i.font.color || (i.font.color = i.color), i.font.lineHeight || (i.font.lineHeight = Math.round(1.15 * i.font.size))); S.xaxis.noTicks && null == S.xaxis.ticks && (S.xaxis.ticks = S.xaxis.noTicks); S.yaxis.noTicks && null == S.yaxis.ticks && (S.yaxis.ticks = S.yaxis.noTicks); S.x2axis && (S.xaxes[1] = G.extend(!0, {}, S.xaxis, S.x2axis), S.xaxes[1].position = "top", null == S.x2axis.min && (S.xaxes[1].min = null), null == S.x2axis.max && (S.xaxes[1].max = null)); S.y2axis && (S.yaxes[1] = G.extend(!0, {}, S.yaxis, S.y2axis), S.yaxes[1].position = "right", null == S.y2axis.min && (S.yaxes[1].min = null), null == S.y2axis.max && (S.yaxes[1].max = null)); S.grid.coloredAreas && (S.grid.markings = S.grid.coloredAreas); S.grid.coloredAreasColor && (S.grid.markingsColor = S.grid.coloredAreasColor); S.lines && G.extend(!0, S.series.lines, S.lines); S.points && G.extend(!0, S.series.points, S.points); S.bars && G.extend(!0, S.series.bars, S.bars); null != S.shadowSize && (S.series.shadowSize = S.shadowSize); null != S.highlightColor && (S.series.highlightColor = S.highlightColor); for (e = 0; e < S.xaxes.length; ++e) b(d, e + 1).options = S.xaxes[e]; for (e = 0; e < S.yaxes.length; ++e) b(p, e + 1).options = S.yaxes[e]; for (var l in C) S.hooks[l] && S.hooks[l].length && (C[l] = C[l].concat(S.hooks[l])); A(C.processOptions, [S]) }(e), function () { g.css("padding", 0).children().filter(function () { return !G(this).hasClass("flot-overlay") && !G(this).hasClass("flot-base") }).remove(), "static" == g.css("position") && g.css("position", "relative"); m = new B("flot-base", g), i = new B("flot-overlay", g), y = m.context, c = i.context, u = G(i.element).unbind(); var t = g.data("plot"); t && (t.shutdown(), i.clear()); g.data("plot", W) }(), n(t), a(), l(), function () { S.grid.hoverable && (u.mousemove(q), u.bind("mouseleave", N)); S.grid.clickable && u.click(P); A(C.bindEvents, [u]) }(); var k = [], D = null; function q(t) { S.grid.hoverable && H("plothover", t, function (t) { return 0 != t.hoverable }) } function N(t) { S.grid.hoverable && H("plothover", t, function (t) { return !1 }) } function P(t) { H("plotclick", t, function (t) { return 0 != t.clickable }) } function H(t, e, i) { var o = u.offset(), n = e.pageX - o.left - w.left, r = e.pageY - o.top - w.top, a = h({ left: n, top: r }); a.pageX = e.pageX, a.pageY = e.pageY; var l = function (t, e, i) { for (var o, n = S.grid.mouseActiveRadius, r = n * n + 1, a = null, l = z.length - 1; 0 <= l; --l) if (i(z[l])) { var s, c, u = z[l], h = u.xaxis, f = u.yaxis, m = u.datapoints.points, d = h.c2p(t), p = f.c2p(e), g = n / h.scale, x = n / f.scale, b = u.datapoints.pointsize; if (h.options.inverseTransform && (g = Number.MAX_VALUE), f.options.inverseTransform && (x = Number.MAX_VALUE), u.lines.show || u.points.show) for (o = 0; o < m.length; o += b) { var v, k, y, w = m[o], M = m[o + 1]; null != w && (g < w - d || w - d < -g || x < M - p || M - p < -x || (y = (v = Math.abs(h.p2c(w) - t)) * v + (k = Math.abs(f.p2c(M) - e)) * k) < r && (r = y, a = [l, o / b])) } if (u.bars.show && !a) { switch (u.bars.align) { case "left": s = 0; break; case "right": s = -u.bars.barWidth; break; default: s = -u.bars.barWidth / 2 } for (c = s + u.bars.barWidth, o = 0; o < m.length; o += b) { var w = m[o], M = m[o + 1], T = m[o + 2]; null != w && (z[l].bars.horizontal ? d <= Math.max(T, w) && d >= Math.min(T, w) && M + s <= p && p <= M + c : w + s <= d && d <= w + c && p >= Math.min(T, M) && p <= Math.max(T, M)) && (a = [l, o / b]) } } } return a ? (l = a[0], o = a[1], b = z[l].datapoints.pointsize, { datapoint: z[l].datapoints.points.slice(o * b, (o + 1) * b), dataIndex: o, series: z[l], seriesIndex: l }) : null }(n, r, i); if (l && (l.pageX = parseInt(l.series.xaxis.p2c(l.datapoint[0]) + o.left + w.left, 10), l.pageY = parseInt(l.series.yaxis.p2c(l.datapoint[1]) + o.top + w.top, 10)), S.grid.autoHighlight) { for (var s = 0; s < k.length; ++s) { var c = k[s]; c.auto != t || l && c.series == l.series && c.point[0] == l.datapoint[0] && c.point[1] == l.datapoint[1] || L(c.series, c.point) } l && j(l.series, l.datapoint, t) } g.trigger(t, [a, l]) } function R() { var t = S.interaction.redrawOverlayInterval; -1 != t ? D = D || setTimeout(O, t) : O() } function O() { var t, e; for (D = null, c.save(), i.clear(), c.translate(w.left, w.top), t = 0; t < k.length; ++t) ((e = k[t]).series.bars.show ? function (t, e) { var i, o = "string" == typeof t.highlightColor ? t.highlightColor : G.color.parse(t.color).scale("a", .5).toString(), n = o; switch (t.bars.align) { case "left": i = 0; break; case "right": i = -t.bars.barWidth; break; default: i = -t.bars.barWidth / 2 } c.lineWidth = t.bars.lineWidth, c.strokeStyle = o, f(e[0], e[1], e[2] || 0, i, i + t.bars.barWidth, function () { return n }, t.xaxis, t.yaxis, c, t.bars.horizontal, t.bars.lineWidth) } : function (t, e) { var i = e[0], o = e[1], n = t.xaxis, r = t.yaxis, a = "string" == typeof t.highlightColor ? t.highlightColor : G.color.parse(t.color).scale("a", .5).toString(); if (i < n.min || i > n.max || o < r.min || o > r.max) return; var l = t.points.radius + t.points.lineWidth / 2; c.lineWidth = l, c.strokeStyle = a; var s = 1.5 * l; i = n.p2c(i), o = r.p2c(o), c.beginPath(), "circle" == t.points.symbol ? c.arc(i, o, s, 0, 2 * Math.PI, !1) : t.points.symbol(c, i, o, s, !1); c.closePath(), c.stroke() })(e.series, e.point); c.restore(), A(C.drawOverlay, [c]) } function j(t, e, i) { var o; "number" == typeof t && (t = z[t]), "number" == typeof e && (o = t.datapoints.pointsize, e = t.datapoints.points.slice(o * e, o * (e + 1))); var n = Y(t, e); -1 == n ? (k.push({ series: t, point: e, auto: i }), R()) : i || (k[n].auto = !1) } function L(t, e) { if (null == t && null == e) return k = [], void R(); var i; "number" == typeof t && (t = z[t]), "number" == typeof e && (i = t.datapoints.pointsize, e = t.datapoints.points.slice(i * e, i * (e + 1))); var o = Y(t, e); -1 != o && (k.splice(o, 1), R()) } function Y(t, e) { for (var i = 0; i < k.length; ++i) { var o = k[i]; if (o.series == t && o.point[0] == e[0] && o.point[1] == e[1]) return i } return -1 } function E(t, e, i, o) { if ("string" == typeof t) return t; for (var n = y.createLinearGradient(0, i, 0, e), r = 0, a = t.colors.length; r < a; ++r) { var l, s = t.colors[r]; "string" != typeof s && (l = G.color.parse(o), null != s.brightness && (l = l.scale("rgb", s.brightness)), null != s.opacity && (l.a *= s.opacity), s = l.toString()), n.addColorStop(r / (a - 1), s) } return n } } G.fn.detach || (G.fn.detach = function () { return this.each(function () { this.parentNode && this.parentNode.removeChild(this) }) }), B.prototype.resize = function (t, e) { if (t <= 0 || e <= 0) throw new Error("Invalid dimensions for plot, width = " + t + ", height = " + e); var i = this.element, o = this.context, n = this.pixelRatio; this.width != t && (i.width = t * n, i.style.width = t + "px", this.width = t), this.height != e && (i.height = e * n, i.style.height = e + "px", this.height = e), o.restore(), o.save(), o.scale(n, n) }, B.prototype.clear = function () { this.context.clearRect(0, 0, this.width, this.height) }, B.prototype.render = function () { var t = this._textCache; for (var e in t) if (m.call(t, e)) { var i = this.getTextLayer(e), o = t[e]; for (var n in i.hide(), o) if (m.call(o, n)) { var r = o[n]; for (var a in r) if (m.call(r, a)) { for (var l, s = r[a].positions, c = 0; l = s[c]; c++) l.active ? l.rendered || (i.append(l.element), l.rendered = !0) : (s.splice(c--, 1), l.rendered && l.element.detach()); 0 == s.length && delete r[a] } } i.show() } }, B.prototype.getTextLayer = function (t) { var e = this.text[t]; return null == e && (null == this.textContainer && (this.textContainer = G("<div class='flot-text'></div>").css({ position: "absolute", top: 0, left: 0, bottom: 0, right: 0, "font-size": "smaller", color: "#545454" }).insertAfter(this.element)), e = this.text[t] = G("<div></div>").addClass(t).css({ position: "absolute", top: 0, left: 0, bottom: 0, right: 0 }).appendTo(this.textContainer)), e }, B.prototype.getTextInfo = function (t, e, i, o, n) { var r, a, l, s, c; return e = "" + e, r = "object" == typeof i ? i.style + " " + i.variant + " " + i.weight + " " + i.size + "px/" + i.lineHeight + "px " + i.family : i, null == (a = this._textCache[t]) && (a = this._textCache[t] = {}), null == (l = a[r]) && (l = a[r] = {}), null == (s = l[e]) && (c = G("<div></div>").html(e).css({ position: "absolute", "max-width": n, top: -9999 }).appendTo(this.getTextLayer(t)), "object" == typeof i ? c.css({ font: r, color: i.color }) : "string" == typeof i && c.addClass(i), s = l[e] = { width: c.outerWidth(!0), height: c.outerHeight(!0), element: c, positions: [] }, c.detach()), s }, B.prototype.addText = function (t, e, i, o, n, r, a, l, s) { var c = this.getTextInfo(t, o, n, r, a), u = c.positions; "center" == l ? e -= c.width / 2 : "right" == l && (e -= c.width), "middle" == s ? i -= c.height / 2 : "bottom" == s && (i -= c.height); for (var h, f = 0; h = u[f]; f++) if (h.x == e && h.y == i) return void (h.active = !0); h = { active: !0, rendered: !1, element: u.length ? c.element.clone() : c.element, x: e, y: i }, u.push(h), h.element.css({ top: Math.round(i), left: Math.round(e), "text-align": l }) }, B.prototype.removeText = function (t, e, i, o, n, r) { if (null == o) { var a = this._textCache[t]; if (null != a) for (var l in a) if (m.call(a, l)) { var s = a[l]; for (var c in s) if (m.call(s, c)) for (var u = s[c].positions, h = 0; f = u[h]; h++) f.active = !1 } } else for (var f, u = this.getTextInfo(t, o, n, r).positions, h = 0; f = u[h]; h++) f.x == e && f.y == i && (f.active = !1) }, G.plot = function (t, e, i) { return new o(G(t), e, i, G.plot.plugins) }, G.plot.version = "0.8.3", G.plot.plugins = [], G.fn.plot = function (t, e) { return this.each(function () { G.plot(this, t, e) }) } }(jQuery), function (i) { function b(t, e) { return e * Math.floor(t / e) } function c(t, e, i, o) { if ("function" == typeof t.strftime) return t.strftime(e); function n(t, e) { return e = "" + (null == e ? "0" : e), 1 == (t = "" + t).length ? e + t : t } var r, a = [], l = !1, s = t.getHours(), c = s < 12; null == i && (i = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]), null == o && (o = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]), r = 12 < s ? s - 12 : 0 == s ? 12 : s; for (var u = 0; u < e.length; ++u) { var h = e.charAt(u); if (l) { switch (h) { case "a": h = "" + o[t.getDay()]; break; case "b": h = "" + i[t.getMonth()]; break; case "d": h = n(t.getDate()); break; case "e": h = n(t.getDate(), " "); break; case "h": case "H": h = n(s); break; case "I": h = n(r); break; case "l": h = n(r, " "); break; case "m": h = n(t.getMonth() + 1); break; case "M": h = n(t.getMinutes()); break; case "q": h = "" + (Math.floor(t.getMonth() / 3) + 1); break; case "S": h = n(t.getSeconds()); break; case "y": h = n(t.getFullYear() % 100); break; case "Y": h = "" + t.getFullYear(); break; case "p": h = c ? "am" : "pm"; break; case "P": h = c ? "AM" : "PM"; break; case "w": h = "" + t.getDay() } a.push(h), l = !1 } else "%" == h ? l = !0 : a.push(h) } return a.join("") } function o(t) { function e(t, e, i, o) { t[e] = function () { return i[o].apply(i, arguments) } } var i = { date: t }; null != t.strftime && e(i, "strftime", t, "strftime"), e(i, "getTime", t, "getTime"), e(i, "setTime", t, "setTime"); for (var o = ["Date", "Day", "FullYear", "Hours", "Milliseconds", "Minutes", "Month", "Seconds"], n = 0; n < o.length; n++) e(i, "get" + o[n], t, "getUTC" + o[n]), e(i, "set" + o[n], t, "setUTC" + o[n]); return i } function v(t, e) { if ("browser" == e.timezone) return new Date(t); if (e.timezone && "utc" != e.timezone) { if ("undefined" == typeof timezoneJS || void 0 === timezoneJS.Date) return o(new Date(t)); var i = new timezoneJS.Date; return i.setTimezone(e.timezone), i.setTime(t), i } return o(new Date(t)) } var k = { second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, month: 2592e6, quarter: 7776e6, year: 525949.2 * 60 * 1e3 }, t = [[1, "second"], [2, "second"], [5, "second"], [10, "second"], [30, "second"], [1, "minute"], [2, "minute"], [5, "minute"], [10, "minute"], [30, "minute"], [1, "hour"], [2, "hour"], [4, "hour"], [8, "hour"], [12, "hour"], [1, "day"], [2, "day"], [3, "day"], [.25, "month"], [.5, "month"], [1, "month"], [2, "month"]], y = t.concat([[3, "month"], [6, "month"], [1, "year"]]), w = t.concat([[1, "quarter"], [2, "quarter"], [1, "year"]]); i.plot.plugins.push({ init: function (t) { t.hooks.processOptions.push(function (t, e) { i.each(t.getAxes(), function (t, e) { var x = e.options; "time" == x.mode && (e.tickGenerator = function (t) { var e = [], i = v(t.min, x), o = 0, n = x.tickSize && "quarter" === x.tickSize[1] || x.minTickSize && "quarter" === x.minTickSize[1] ? w : y; null != x.minTickSize && (o = "number" == typeof x.tickSize ? x.tickSize : x.minTickSize[0] * k[x.minTickSize[1]]); for (var r = 0; r < n.length - 1 && !(t.delta < (n[r][0] * k[n[r][1]] + n[r + 1][0] * k[n[r + 1][1]]) / 2 && n[r][0] * k[n[r][1]] >= o) ; ++r); var a, l, s = n[r][0]; "year" == (u = n[r][1]) && (null != x.minTickSize && "year" == x.minTickSize[1] ? s = Math.floor(x.minTickSize[0]) : (a = Math.pow(10, Math.floor(Math.log(t.delta / k.year) / Math.LN10)), s = (l = t.delta / k.year / a) < 1.5 ? 1 : l < 3 ? 2 : l < 7.5 ? 5 : 10, s *= a), s < 1 && (s = 1)), t.tickSize = x.tickSize || [s, u]; var c = t.tickSize[0], u = t.tickSize[1], h = c * k[u]; "second" == u ? i.setSeconds(b(i.getSeconds(), c)) : "minute" == u ? i.setMinutes(b(i.getMinutes(), c)) : "hour" == u ? i.setHours(b(i.getHours(), c)) : "month" == u ? i.setMonth(b(i.getMonth(), c)) : "quarter" == u ? i.setMonth(3 * b(i.getMonth() / 3, c)) : "year" == u && i.setFullYear(b(i.getFullYear(), c)), i.setMilliseconds(0), k.minute <= h && i.setSeconds(0), k.hour <= h && i.setMinutes(0), k.day <= h && i.setHours(0), 4 * k.day <= h && i.setDate(1), 2 * k.month <= h && i.setMonth(b(i.getMonth(), 3)), 2 * k.quarter <= h && i.setMonth(b(i.getMonth(), 6)), k.year <= h && i.setMonth(0); var f = 0, m = Number.NaN; do { var d, p, g = m, m = i.getTime(); e.push(m), "month" == u || "quarter" == u ? c < 1 ? (i.setDate(1), d = i.getTime(), i.setMonth(i.getMonth() + ("quarter" == u ? 3 : 1)), p = i.getTime(), i.setTime(m + f * k.hour + (p - d) * c), f = i.getHours(), i.setHours(0)) : i.setMonth(i.getMonth() + c * ("quarter" == u ? 3 : 1)) : "year" == u ? i.setFullYear(i.getFullYear() + c) : i.setTime(m + h) } while (m < t.max && m != g); return e }, e.tickFormatter = function (t, e) { var i = v(t, e.options); if (null != x.timeformat) return c(i, x.timeformat, x.monthNames, x.dayNames); var o = e.options.tickSize && "quarter" == e.options.tickSize[1] || e.options.minTickSize && "quarter" == e.options.minTickSize[1], n = e.tickSize[0] * k[e.tickSize[1]], r = e.max - e.min, a = x.twelveHourClock ? " %p" : "", l = x.twelveHourClock ? "%I" : "%H", s = n < k.minute ? l + ":%M:%S" + a : n < k.day ? r < 2 * k.day ? l + ":%M" + a : "%b %d " + l + ":%M" + a : n < k.month ? "%b %d" : o && n < k.quarter || !o && n < k.year ? r < k.year ? "%b" : "%b %Y" : o && n < k.year ? r < k.year ? "Q%q" : "Q%q %Y" : "%Y"; return c(i, s, x.monthNames, x.dayNames) }) }) }) }, options: { xaxis: { timezone: null, timeformat: null, twelveHourClock: !1, monthNames: null } }, name: "time", version: "1.0" }), i.plot.formatDate = c, i.plot.dateGenerator = v }(jQuery), function (a, l, s) { var c, u = [], h = a.resize = a.extend(a.resize, {}), f = !1, i = "setTimeout", m = "resize", d = m + "-special-event", p = "pendingDelay", o = "activeDelay", n = "throttleWindow"; function g(t) { !0 === f && (f = t || 1); for (var e = u.length - 1; 0 <= e; e--) { var i, o, n, r = a(u[e]); r[0] == l || r.is(":visible") ? (i = r.width(), o = r.height(), !(n = r.data(d)) || i === n.w && o === n.h || (r.trigger(m, [n.w = i, n.h = o]), f = t || !0)) : ((n = r.data(d)).w = 0, n.h = 0) } null !== c && (f && (null == t || t - f < 1e3) ? c = l.requestAnimationFrame(g) : (c = setTimeout(g, h[p]), f = !1)) } h[p] = 200, h[o] = 20, h[n] = !0, a.event.special[m] = { setup: function () { if (!h[n] && this[i]) return !1; var t = a(this); u.push(this), t.data(d, { w: t.width(), h: t.height() }), 1 === u.length && (c = s, g()) }, teardown: function () { if (!h[n] && this[i]) return !1; for (var t = a(this), e = u.length - 1; 0 <= e; e--) if (u[e] == this) { u.splice(e, 1); break } t.removeData(d), u.length || ((f ? cancelAnimationFrame : clearTimeout)(c), c = null) }, add: function (t) { if (!h[n] && this[i]) return !1; var r; function e(t, e, i) { var o = a(this), n = o.data(d) || {}; n.w = e !== s ? e : o.width(), n.h = i !== s ? i : o.height(), r.apply(this, arguments) } if (a.isFunction(t)) return r = t, e; r = t.handler, t.handler = e } }, l.requestAnimationFrame || (l.requestAnimationFrame = l.webkitRequestAnimationFrame || l.mozRequestAnimationFrame || l.oRequestAnimationFrame || l.msRequestAnimationFrame || function (t, e) { return l.setTimeout(function () { t((new Date).getTime()) }, h[o]) }), l.cancelAnimationFrame || (l.cancelAnimationFrame = l.webkitCancelRequestAnimationFrame || l.mozCancelRequestAnimationFrame || l.oCancelRequestAnimationFrame || l.msCancelRequestAnimationFrame || clearTimeout) }(jQuery, this), jQuery.plot.plugins.push({ init: function (e) { function i() { var t = e.getPlaceholder(); 0 != t.width() && 0 != t.height() && (e.resize(), e.setupGrid(), e.draw()) } e.hooks.bindEvents.push(function (t, e) { t.getPlaceholder().resize(i) }), e.hooks.shutdown.push(function (t, e) { t.getPlaceholder().unbind("resize", i) }) }, options: {}, name: "resize", version: "1.0" }), function (l) { function e(t, e, i, o) { var n = "categories" == e.xaxis.options.mode, r = "categories" == e.yaxis.options.mode; if (n || r) { var a, l, s = o.format; s || (a = e, (s = []).push({ x: !0, number: !0, required: !0 }), s.push({ y: !0, number: !0, required: !0 }), (a.bars.show || a.lines.show && a.lines.fill) && (l = !!(a.bars.show && a.bars.zero || a.lines.show && a.lines.zero), s.push({ y: !0, number: !0, required: !1, defaultValue: 0, autoscale: l }), a.bars.horizontal && (delete s[s.length - 1].y, s[s.length - 1].x = !0)), o.format = s); for (var c = 0; c < s.length; ++c) s[c].x && n && (s[c].number = !1), s[c].y && r && (s[c].number = !1) } } function s(t) { var e = []; for (var i in t.categories) { var o = t.categories[i]; o >= t.min && o <= t.max && e.push([o, i]) } return e.sort(function (t, e) { return t[0] - e[0] }), e } function o(t, e, i) { if ("categories" == t[e].options.mode) { if (!t[e].categories) { var o = {}, n = t[e].options.categories || {}; if (l.isArray(n)) for (var r = 0; r < n.length; ++r) o[n[r]] = r; else for (var a in n) o[a] = n[a]; t[e].categories = o } t[e].options.ticks || (t[e].options.ticks = s), function (t, e, i) { for (var o = t.points, n = t.pointsize, r = t.format, a = e.charAt(0), l = function (t) { var e = -1; for (var i in t) t[i] > e && (e = t[i]); return e + 1 }(i), s = 0; s < o.length; s += n) if (null != o[s]) for (var c = 0; c < n; ++c) { var u = o[s + c]; null != u && r[c][a] && (u in i || (i[u] = l, ++l), o[s + c] = i[u]) } }(i, e, t[e].categories) } } function i(t, e, i) { o(e, "xaxis", i), o(e, "yaxis", i) } l.plot.plugins.push({ init: function (t) { t.hooks.processRawData.push(e), t.hooks.processDatapoints.push(i) }, options: { xaxis: { categories: null }, yaxis: { categories: null } }, name: "categories", version: "1.0" }) }(jQuery);